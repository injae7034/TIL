# 19일에 공부한 내용을 적었습니다.
## 어제 구현한 자동차 경주 게임을 처음부터 다시 구현하였습니다.
## 그리고 다시 피드백 강의를 보았습니다.
## 까먹은 사항
1. Random이 들어가는 코드는 테스트하기 힘들어지는데 이 때, 
메소드 내부에서 Random요소를 상위로 끌어올림으로써<br><br>
테스트할 수 있는 구조로 만들 수 있습니다.<br><br>
2. 하지만 만약에 시그니처를 손댈 수 없는 상황이라면 이 때는 어떻게 해야 Random이 있는 코드를 테스트할 수 있도록 변경할 수 있을까요?<br><br>
이 때는 Random이 있는 메소드의 접근제어자를 private에서 protected로 바꿔 준 다음에<br><br>
테스트코드에서 클래스를 생성하면서 이를 오버라이딩하여 원하는 테스트 결과가 나올 수 있도록 재정의해줍니다.<br><br>
3. 또한 Random으로 생성한 숫자가 4이상인지 아닌지 판단하기 위해서<br><br>
만약에 이 로직이 빈번하게 변경될 경우에는 인터페이스를 생성하여 정의할 수 있습니다.<br><br>
메소드를 하나만 가지고 있는 함수형인터페이스를 정의한 다음에 이를 구현하는 클래스를 정의해주고<br><br>
여기에 Random으로 생성한 숫자가 4이상인지 판단하는 로직을 다 옮겨서 여기서 구현을 합니다.<br><br>
그러면 기존에 Random으로 생성한 숫자가 4이상인지 판단하던 RacingGame에는 MovingStrategy라는 객체를 입력받아<br><br>
거기서 함수형인터페이스의 함수를 호출하여 그 여부를 판단하면 됩니다.<br><br>
테스트를 할 때 함수형인터페이스를 익명클래스로 정의하던 것을 람다를 사용하면 훨씬 더 간단하게 테스트할 수 있습니다.<br><br>
4. 도메인 영역을 구현할 때 될 수 있으면 getter 메소드와 setter 메소드는 사용하지 않는 것이 좋습니다.<br><br>
특히, setter메소드는 구현하지 않아도 도메인 영역 구현에는 아무 문제가 없기 때문에 왠만하면 쓰지 말고,<br><br>
getter메소드 역시 피할 수 있을 때까지는 안쓰도록 최대한 노력해보자.<br><br>
값을 꺼내서 비교하려고 하지말고, 객체들끼리 비교하도록 노력해보자.<br><br>
객체에서 get을 통해 직접 값을 꺼내거나 set을 통해 값을 직접 변경하려고 하지 말고<br><br>
객체에 메세지를 보내서 객체내부에서 처리하도록 노력하자.<br><br>
5. RacingGame의 멤버인 List\<Car\>를 wrapping하는 일급컬렉셕 Cars를 사용해서<br><br>
List\<Car\>를 함부로 지우거나 변경할 수 없게 만들 수 있습니다.<br><br>
6. TDD로 구현할 때, 테스트를 수월하게 하기 위해서 생성자를 여러가지 형태로 정의할 수 있습니다.<br><br>
예를 들어 Car에서 원래는 name만 있으면 car를 생성하고, position은 초기값이 0이지만<br><br>
우승자를 구하기 위해서 race 메소드를 남발해야하는데<br><br>
애초에 생성자에서 position을 지정할 수 있게 하면 Car를 생성함과 동시에 우승자를 구하는 테스트를 할 수 있습니다.<br><br>
